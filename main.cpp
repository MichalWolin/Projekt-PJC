#include <iostream>
#include <vector>
#include <string>
#include <fmt/ranges.h>
#include <filesystem>
#include <fmt/std.h>
#include <map>

#include "addCategory.h"
#include "addPassword.h"
#include "editPassword.h"
#include "findPassword.h"
#include "removeCategory.h"
#include "removePassword.h"
#include "sortPasswords.h"

struct Password{
    std::string name;
    std::string password;
    std::string webpage;
    std::string login;
    std::map<int, std::string> categories;

    Password(const std::string &name, const std::string &password, const std::string &webpage,
             const std::string &login, const std::map<int, std::string> &categories) :
             name(name), password(password), webpage(webpage),
             login(login), categories(categories) {}
};

std::string getPath();
long masterKey();

int main() {
    auto key = masterKey();
    auto path = getPath();
//    auto passwords = getPasswords(path);
    bool isRunning = true;

    while(isRunning){
        fmt::println("Choose one of the options below:\n"
                   "1 -> Find password\n"
                   "2 -> Sort password\n"
                   "3 -> Add password\n"
                   "4 -> Edit password\n"
                   "5 -> Remove password\n"
                   "6 -> Add category\n"
                   "7 -> Remove category\n"
                   "0 -> Exit");
        int option;
        std::cin >> option;

        while(option < 0 || option > 7){
            fmt::println("Invalid option! Try again:");
            std::cin >> option;
        }

        switch(option){
            case 0:
                isRunning = false;
                break;
            case 1:
                fmt::print("not yet implemented lol");
                break;
            case 2:
                sortPasswords(path);
                break;
            case 3:
                addPassword(path, key);
                break;
            case 4:
                fmt::print("not yet implemented lol");
                break;
            case 5:
                fmt::print("not yet implemented lol");
                break;
            case 6:
                fmt::print("not yet implemented lol");
                break;
            case 7:
                fmt::print("not yet implemented lol");
                break;
        }
    }
}



/**
 * @brief Returns path to the file
 *
 * This function returns the path to the file either in this folder or an absolute path to the file.
 * The user can choose from existing files in this directory or enter an absolute path.
 * If the user chooses to enter an absolute path, the function checks if the file exists.
 * If the file doesn't exist, the user is asked to enter the path again.
 *
 * @param option Stores the option entered by the user.
 */
std::string getPath(){
    fmt::println("To choose from existing file in this directory type 1, to enter an absolute path type 2:");
    int option;
    std::cin >> option;

    while(option < 1 || option > 2){
        fmt::println("Incorrect option! Type 1 for existing file or type 2 to enter an absolute path:");
        std::cin >> option;
    }

    if(option == 1){
        fmt::println("Choose file from this directory (type g.e. 1)\n***");
        auto dirIter = std::filesystem::directory_iterator("..");
        int fileIter = 1;
        std::vector<std::string> paths;
        for (auto const &entry: dirIter){
            if(entry.is_regular_file() && entry.path().extension() == ".vault") {
                fmt::println("Option no. {}: {}", fileIter++, entry.path());
                paths.push_back(entry.path().string());
            }
        }
        fmt::print("***\n");

        int fileNo;
        std::cin >> fileNo;

        while(fileNo < 1 || fileNo > fileIter){
            fmt::print("Incorrect file number! Try again:\n");
        }

        return paths.at(fileNo - 1);
    }else{
        fmt::print("Enter an absolute path to vault:\n");
        std::string path;
        std::cin >> path;
        return path;
    }
}

/**
 * @brief Returns master key
 *
 * This function returns the master key which is used to encrypt and decrypt passwords.
 * It is generated by multiplying the ASCII values of the characters of the master password.
 *
 * @param masterPassword Stores the master password entered by the user.
 * @param key Stores the master key.
 */
long masterKey(){
    std::string masterPassword;
    fmt::println("Enter your master password:");
    std::cin >> masterPassword;
    long key = 1;
    for (int i = 0; i < masterPassword.size(); ++i) {
        key *= masterPassword.at(0);
    }
    return key;
}





