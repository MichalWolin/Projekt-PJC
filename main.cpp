#include <iostream>
#include <vector>
#include <string>
#include <fmt/core.h>
#include <filesystem>
#include <fmt/std.h>
#include <map>
#include <fstream>

#include "addCategory.h"
#include "addPassword.h"
#include "editPassword.h"
#include "findPassword.h"
#include "removeCategory.h"
#include "removePassword.h"
#include "sortPasswords.h"
#include "Password.h"


std::string getPath();
long masterKey();
std::vector<std::string> getCategories(const std::string& path);
std::vector<Password> getPasswords(const std::string& path, const long& key);
void writeFile(const std::string& path, const std::vector<std::string>& categories,
               const std::vector<Password>& passwords, const long& key);
std::string encryptPassword(const std::string& password, const long& key);

int main() {
    fmt::println("USE THE SAME MASTER KEY EVERY TIME YOU RUN THE PROGRAM!");
    fmt::println("IF YOU USE DIFFERENT MASTER KEY, YOU WILL CORRUPT THE FILE!");
    fmt::println("EXIT THROUGH THE PROGRAM! OTHERWISE YOUR CHANGES WON'T BE SAVED!\n");

    auto key = masterKey();
    auto path = getPath();
    auto categories = getCategories(path);
    auto passwords = getPasswords(path, key);
    bool isRunning = true;

    while(isRunning){
        fmt::println("\nChoose one of the options below:\n"
                   "1 -> Find password\n"
                   "2 -> Sort password\n"
                   "3 -> Add password\n"
                   "4 -> Edit password\n"
                   "5 -> Remove password\n"
                   "6 -> Add category\n"
                   "7 -> Remove category\n"
                   "0 -> Exit");
        int option;
        std::cin >> option;

        while(option < 0 || option > 7){
            fmt::println("Invalid option! Try again:");
            std::cin >> option;
        }

        switch(option){
            case 0:
                isRunning = false;
                writeFile(path, categories, passwords, key);
                break;
            case 1:
                findPassword(passwords, categories);
                break;
            case 2:
                sortPasswords(passwords);
                break;
            case 3:
                addPassword(passwords, categories);
                break;
            case 4:
                editPassword(passwords);
                break;
            case 5:
                removePassword(passwords);
                break;
            case 6:
                addCategory(categories);
                break;
            case 7:
                fmt::print("not yet implemented lol");
                break;
        }
    }
}



/**
 * @brief Returns path to the file
 *
 * This function returns the path to the file either in this folder or an absolute path to the file.
 * The user can choose from existing files in this directory or enter an absolute path.
 * If the user chooses to enter an absolute path, the function checks if the file exists.
 * If the file doesn't exist, the user is asked to enter the path again.
 *
 * @param option Stores the option entered by the user.
 */
std::string getPath(){
    fmt::println("To choose from existing file in this directory type 1, to enter an absolute path type 2:");
    int option;
    std::cin >> option;

    while(option < 1 || option > 2){
        fmt::println("Incorrect option! Type 1 for existing file or type 2 to enter an absolute path:");
        std::cin >> option;
    }

    if(option == 1){
        fmt::println("Choose file from this directory (type g.e. 1)\n***");
        auto dirIter = std::filesystem::directory_iterator("..");
        int fileIter = 1;
        std::vector<std::string> paths;
        for (auto const &entry: dirIter){
            if(entry.is_regular_file() && entry.path().extension() == ".vault") {
                fmt::println("Option no. {}: {}", fileIter++, entry.path());
                paths.push_back(entry.path().string());
            }
        }
        fmt::print("***\n");

        int fileNo;
        std::cin >> fileNo;

        while(fileNo < 1 || fileNo > fileIter){
            fmt::print("Incorrect file number! Try again:\n");
        }

        return paths.at(fileNo - 1);
    }else{
        fmt::print("Enter an absolute path to vault:\n");
        std::string path;
        std::cin >> path;
        return path;
    }
}

/**
 * @brief Returns master key
 *
 * This function returns the master key which is used to encrypt and decrypt passwords.
 * It is generated by multiplying the ASCII values of the characters of the master password.
 *
 * @param masterPassword Stores the master password entered by the user.
 * @param key Stores the master key.
 */
long masterKey(){
    std::string masterPassword;
    fmt::println("Enter your master password:");
    std::cin >> masterPassword;
    long key = 1;
    for (int i = 0; i < masterPassword.size(); ++i) {
        key *= masterPassword.at(0);
    }
    return key;
}

std::vector<std::string> getCategories(const std::string& path){
    std::vector<std::string> categories;

    auto vault = std::fstream(path, std::ios::in);
    std::string line;
    if(std::getline(vault, line)){
        std::stringstream ss(line);
        std::string category;
        while(std::getline(ss, category, ':')){
            categories.push_back(category);
        }
    }
    vault.close();

    return categories;
}

std::vector<Password> getPasswords(const std::string& path, const long& key) {
    std::vector<Password> passwords;

    auto vault = std::fstream(path, std::ios::in);
    std::string line;
    std::getline(vault, line);

    while(std::getline(vault, line)) {
        std::stringstream ss(line);
        std::string name, password, webpage, login, category;
        std::map<std::string, std::string> categories;
        std::getline(ss, name, ':');
        std::getline(ss, password, ':');
        std::getline(ss, webpage, ':');
        std::getline(ss, login, ':');
        while (std::getline(ss, category, ':')) {
            std::string categoryName, categoryValue;
            categoryName = category;
            std::getline(ss, category, ':');
            categoryValue = category;
            categories.insert(std::pair<std::string, std::string>(categoryName, categoryValue));
        }

        passwords.emplace_back(name, encryptPassword(password, key), webpage, login, categories);
    }

    return passwords;
}

void writeFile(const std::string& path, const std::vector<std::string>& categories,
               const std::vector<Password>& passwords, const long& key){
    auto vault = std::fstream(path, std::ios::out);

    for (int i = 0; i < categories.size(); ++i) {
        if(i == categories.size() - 1)
            vault << categories.at(i);
        else
            vault << categories.at(i) << ":";
    }
    vault << "\n";

    for (const auto& password : passwords) {
        vault << password.getName() << ":"
              << encryptPassword(password.getPassword(), key) << ":"
              << password.getWebpage() << ":"
              << password.getLogin();
        for (const auto& category : password.getCategories()) {
            vault << ":" << category.first << ":" << category.second;
        }
        vault << "\n";
    }
}

std::string encryptPassword(const std::string& password, const long& key){
    std::string encryptedPassword = "";
    for (int i = 0; i < password.length(); ++i) {
        encryptedPassword += (char)(password.at(i) ^ key);
    }
    return encryptedPassword;
}